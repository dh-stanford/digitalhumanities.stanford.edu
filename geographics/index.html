<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>Geographics :: Digital Humanities @ Stanford</title>

  

  <link rel="shortcut icon" type="image/x-icon" href="/">

  <!-- Font Awesome Icons -->
  <link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css"
    integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" rel="stylesheet">

  <!-- Google Fonts-->
  <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700" rel="stylesheet">

  <!-- Bootstrap Modified -->
  <link rel="stylesheet" href="/assets/css/main.css" ">

  <!-- Theme Stylesheet -->
  <link rel=" stylesheet" href="/assets/css/theme.css" ">

  <style>
    /* add margin if scroll bar not visible
      Note: leaving space for a scroll bar can result in obviously uneven margins
      on smaller screens when there is no scroll bar.  This is potentially an issue
      on environments without overlay scrollbars and very narrow viewports, but 
      such environments are very uncommon and in my contrived examples behaviour
      is entirely acceptable imo. */
    body {
      margin-left: calc(100vw - 100%);
      margin-right: 0;
      overflow-x: hidden;
    }
    .navbar { left: calc(100vw - 100%); }
  </style>


  <meta property="og:title" content="Geographics" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/geographics/" />
<meta property="og:site_name" content="Digital Humanities at Stanford" />
<meta property="og:description" content="" />
<meta property="og:image" content="" />
<meta property="og:image:alt" content="Post image" />
<meta name="description" content="" />


</head>

<body class=" ">

  <!-- Navbar -->
  <nav class="topnav navbar navbar-expand-lg navbar-light bg-white fixed-top" id="MagicMenu">
    <div class="container">
      <a class="navbar-brand" href="/">
        <strong>Digital Humanities @ Stanford</strong>
      </a>
      <button aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation"
        class="navbar-toggler collapsed" data-target="#navbarColor02" data-toggle="collapse" type="button">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="navbar-collapse collapse" id="navbarColor02" style="">
        <ul class="navbar-nav mr-auto d-flex align-items-center">
          <li class="nav-item">
  <a class="nav-link" href="/">Home</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="/about-dh-stanford">About</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="/projects">Projects</a>
</li>
<li class="nav-item">
  <a target="_blank" class="nav-link" href="http://library.stanford.edu/research/cidr/workshops">Workshops</a>
</li>
<li class="nav-item">
  <a target="_blank" class="nav-link" href="https://dhminor.stanford.edu/">DH Minor</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="/slavic">Slavic</a>
</li>

        </ul>
        <ul class="navbar-nav ml-auto d-flex align-items-center">
          <script src="/assets/js/lunr.min.js"></script>

<form class="bd-search hidden-sm-down" onSubmit="return lunrSearch(document.getElementById('lunrsearch').value);">
  <input type="text" class="form-control text-small" id="lunrsearch" name="q" value=""
    placeholder="Type keyword and enter..." />
</form>

<div id="lunrsearchresults"></div>

<script>
  const lunrSearchResults = document.getElementById("lunrsearchresults");
  let idx;
  let docs;

  fetch("/lunr-index.json")
    .then((response) => response.json())
    .then((data) => {
      idx = lunr.Index.load(data.index);
      documents = data.documents;
    });

  const closeSearch = () => {
    lunrSearchResults.style.display = "none";
    document.body.classList.remove("modal-open");
  };

  document.body.addEventListener("click", (event) => {
    if (event.target.id !== "lunrsearchresults" && document.body.classList.contains("modal-open")) closeSearch();
  });

  document.body.addEventListener("keydown", (event) => {
    if (event.key == "Escape" && document.body.classList.contains("modal-open")) closeSearch();
  });

  const lunrSearch = (term) => {
    lunrSearchResults.style.display = "block";
    document.body.classList.add("modal-open");

    lunrSearchResults.innerHTML = `
    <div id="resultsmodal" class="modal fade show d-block" tabindex="-1" role="dialog" aria-labelledby="resultsmodal">
      <div class="modal-dialog shadow-lg" role="document">
        <div class="modal-content">
          <div class="modal-header" id="modtit">
            <h5 class='modal-title'>Search results for "${term}"</h5>
            <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button>
          </div>
          <div class="modal-body">
            <ul class="mb-0"> </ul>
          </div>
        </div>
      </div>
    </div>`;

    lunrSearchResults.querySelector("#btnx").addEventListener("click", closeSearch);

    //put results on the screen.
    const results = idx.search(term);
    if (results.length > 0) {
      results.forEach(({ ref }) => {
        const { url, title, excerpt } = documents[ref];
        const li = document.createElement("li");
        li.classList.add("lunrsearchresult");
        li.innerHTML = `
          <a href='${url}'>
            <span class='title'>${title}</span>
            <br />
            <small>
              <span class='body'>${excerpt}</span>
              <br />
              <span class='url'>${url}</span>
            </small>
          </a>
        `;
        lunrSearchResults.querySelector("ul").appendChild(li);
      });
    } else {
      const li = document.createElement("li");
      li.classList.add("lunrsearchresult");
      li.innerText = "Sorry, no results found. Close & try a different search!";
      lunrSearchResults.querySelector("ul").appendChild(li);
    }
    return false;
  }
</script>
<style>
  #lunrsearchresults {
    position: relative;
    z-index: 1100;
  }

  #lunrsearchresults .modal {
    left: calc(100vw - 100%);
  }

  #lunrsearchresults .modal-dialog {
    display: flex;
    max-height: calc(100vh - 3.5em);
  }

  #lunrsearchresults .modal-body {
    max-height: 100%;
    overflow-y: auto;
  }

  .lunrsearchresult .title {
    color: #d9230f;
  }

  .lunrsearchresult .url {
    color: silver;
  }

  .lunrsearchresult a {
    display: block;
    color: #777;
  }

  .lunrsearchresult a:hover,
  .lunrsearchresult a:focus {
    text-decoration: none;
  }

  .lunrsearchresult a:hover .title {
    text-decoration: underline;
  }
</style>

        </ul>
      </div>
    </div>
  </nav>

  <!-- Content -->
  <main class="site-content" role="main">
    <div class="container">
  <div class="jumbotron jumbotron-fluid mb-3 pl-0 pt-0 pb-0 bg-white position-relative">
    <div class="h-100 tofront">
      <div
        class="row  justify-content-between ">
        <div
          class=" col-md-6  pr-0 pr-md-4 pt-4 pb-4 align-self-center">
          <h1 class="display-4 mb-4 article-headline">Geographics</h1>
          <div class="d-flex align-items-center">
            
            <small class="ml-3">
              Elijah Meeks<span class="text-muted d-block mt-1">January 6, 2014</span>
            </small>
          </div>
        </div>
        
        <div class="col-md-6 pr-0 align-self-center">
          <img class="rounded" src="../post-images/ov2_routeNormalization1.png" alt="Geographics">
        </div>
        
      </div>
    </div>
  </div>
</div>

<div class="container-lg pt-4 pb-4">
  <div class="row justify-content-center">
    <!-- Share -->
    <div class="col-lg-2 pr-4 mb-4 col-md-12">
      <div class="sticky-top sticky-top-offset text-center">
        <div class="text-muted">
          
        </div>
        <div class="share d-inline-block">
          <!-- AddToAny BEGIN -->
          <div class="a2a_kit a2a_kit_size_32 a2a_default_style">
            
          </div>
     
          <!-- AddToAny END -->
        </div>
      </div>
    </div>

    <div class="col-md-12 col-lg-8">
      <!-- Article -->
      <article class="article-post">
        <p><a href="http://orbis.stanford.edu/">ORBIS</a> is nearly two years old, and the ongoing update to the site has me once again in conversation with a cartographers, geographers, designers, and digital humanists. A new response I get, when describing the growing feature list of <a href="http://orbis.stanford.edu/v2/">ORBIS v2</a>, is some variation of &quot;What do people use this for?&quot; The fact that ORBIS still generates decent traffic* seems even more remarkable than its appearance in gaming forums, college essays and high school courses. The ultimate answer to the question is that most people play with it, running routes and contrasting the results with their own experience or intuition of travel in the regions where they run their routes. But, as has been noted in earlier essays about the project, ORBIS was built for the purpose of displaying dynamic distance cartograms, and the Google Maps interface was just an affordance that came along from developing that functionality. And so one of my major goals in updating ORBIS is to dramatically improve the cartogram functionality, as well as provide mechanisms to improve the use and understanding of what is a very abstract concept. This is as much a design challenge as a coding challenge, especially when it comes to properly distorting the routes that make up the network along with the sites. This post will get into quite a bit of technical detail as far as how that was done, and also touch on the growing integration of graphics and geography in the web mapping world.</p>
<p><img src="../post-images/ov2_routeNormalization1.png" alt=""></p>
<p>First, a quick definition of a dynamic distance cartogram. The image above is a distortion of the geography of the ORBIS network to reflect the amount of time it would take to travel from Rome to the various other 700+ sites in the ORBIS network. This kind of distortion is available from any site in ORBIS v2 by clicking on the site and selecting Cartogram. The terrain map has faded because what we are no longer looking at traditional geographic information, instead we're seeing the combination of geographic position of sites relative to Rome (in that their angle from Rome is maintained) but with the distance from Rome set to represent the relative distance as it would take to navigate to that site along the network. So, Britannia is still up and to the left, while Egypt is still down and to the right, but the individual sites, if you measured their distance from Rome, correspond to the cost it would take to get there. In this case, the cost is time, but that cost may be the expense to ship grain or passengers, or the total length of the routes (which, as you'd expect, produces much less distortion).</p>
<p>Distorting the position of sites is easy, given that each site is a single coordinate (or point, in geogrphic information systems-speak). You just need to calculate the angle from Rome and change the distance while maintaining that angle. But one of the critiques that Scott Weingart made in his <a href="http://www.scottbot.net/HIAL/?p=15585">review of ORBIS</a> was that the original cartogram does not distort routes, which provide much of the context necessary for understanding a cartogram. As you can see in the example above, the new cartogram handles routes along with sites, and does so with good performance (at least in Chrome and Safari--I've given up trying to build things for Firefox's horrible SVG performance). This is accomplished in D3 by selecting the path elements that represent our routes and calculating new &quot;d&quot; attributes for them (the &quot;d&quot; attribute determines how a path is drawn in SVG) like so:</p>
<p>d3.selectAll(&quot;path.links&quot;).each(function(d) {</p>
<p>var xposition = -1;
var yposition = -1;
var lineLength = d.coordinates.length - 1;
var cartoRamp = d3.scale.linear().range([d.properties.source[&quot;cost&quot;][0],d.properties.target[&quot;cost&quot;][0]]).domain([0, lineLength]);
cartoPath =
d3.svg.line()
.x(function(p) {return lineInterpolatorX(p)})
.y(function(p) {return lineInterpolatorY(p)});</p>
<p>function lineInterpolatorX (incomingRoute) {
xposition++;return findx(cartoRamp(xposition),incomingRoute[0],incomingRoute[1],centerX,centerY)
}</p>
<p>function lineInterpolatorY (incomingRoute) {
yposition++;return findy(cartoRamp(yposition),incomingRoute[0],incomingRoute[1],centerX,centerY)
}
d.cartoD = cartoPath(d.coordinates);
})</p>
<p>Each path element is selected and instantiates its own <a href="https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line">d3.svg.line()</a> constructor to create the new, distorted line. This constructor operates on a set of x/y coordinates, but in the case of the lines we're working with, those x/y coordinates cannot be passed as simple values but instead need to be interpolated based on the distortion of the system that we're representing with the cartogram. A simple polyline, like the kind we're using for the routes in ORBIS, is a collection of coordinate pairs, and each coordinate pair needs to be positions relative to the distortion of the two sites that the line connects. So, we build a linear ramp using <a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#linear-scales">d3.scale.linear()</a> from the cost to reach Site A to the cost to reach Site B and map it to the number of points that makes up the line. We use this linear ramp to determine the interpolated cost at each point in the polyline to create a distortion of the route that distorts the points near Site A more like Site A and the points on the route near Site B more like Site B and the points in the middle as some mix based on the order they appear in the line.</p>
<p>But this method has a problem. It assumes that the points that make up the polyline are equidistant. As a result, if you have a route that is significantly more complex on one end or the other (such as switchbacks or other changes in course), then it will have more points to represent that complexity which may not map to actual length of the route.
<img src="../post-images/routes_simp.png" alt=""></p>
<p>This happens with the ORBIS route data because the line simplification it uses to create lightweight geodata comes from a GIS focus on resolution and maintaining details given a particular scale, which can result in polygons and polylines maintaining uneven complexity across their surface. There are two ways to resolve this. The first would be to factor the actual length of the line at the point we're distorting and with a cost ramp that was mapped to the length of the route instead of the number of points in the route, then we would see proper distortion. The other way to solve this is to normalize the displayed routes by pairing D3's projection() function with the built-in SVG getPointAtLength function to normalize the routes. I chose this direction because it would also reduce the number of vertices, overall, in the routes and should improve performance. The code to do that:</p>
<p>simplifiedGeoms = [];</p>
<p>d3.selectAll(&quot;path.routes&quot;).each(function(d,i) {
var segLength = d3.select(this).node().getTotalLength();
var simplifiedObject = {coordinates: [], type:&quot;LineString&quot;, id: d.id, properties: d.properties};
for (x=0;x&lt;=1;x+=.1) {
var segPoint = d3.select(this).node().getPointAtLength(segLength * x);
var segPointProjected = projection.invert([segPoint.x,segPoint.y])
simplifiedObject.coordinates.push([segPointProjected[0],segPointProjected[1]]);
}
simplifiedGeoms.push(simplifiedObject);
})</p>
<p>routeG.selectAll(&quot;.routes&quot;)
.data(simplifiedGeoms)
.attr(&quot;d&quot;, path)</p>
<p>Notice that for this to work, we need to have already created the graphical objects that represent the geographic data for the routes. This requires us to project the data and draw it in the DOM. Once we have SVG paths that represent each route, we can take advantage of the built-in SVG functionality to segment the lines equidistantly relying not on their geographic length but on their graphical length. D3's handy projection.invert() function allows us to create the projected coordinates from the graphical coordinates returned by getPointAtLength. The underlying data used to determine route cost and shape is unchanged, and even with dramatic simplification the appearance of the line maintains most of its integrity.
<img src="../post-images/simple.gif" alt=""></p>
<p>This gif cycles between no simplification of the routes, a simplification to 10 equidistant points along the polyline, and a simplification to 4 equidistant points along the polyline.</p>
<p>The result of simplifying the routes in this manner is not some massive change. As I noted earlier, there weren't any routes troublesome enough to create significant distortion. Compare the initial cartogram at the beginning of this post with the cartogram drawn with lines that have been normalized in this manner and you'll be hard-pressed to spot the differences:</p>
<p><img src="../post-images/ov2_routeNormalization2.png" alt=""></p>
<p>One of the places where you can see a correction in route distortion happens with the routes to Mursa (now Osijek, Croatia) from Siscia (Sisak, Croatia) and from Poetovio (now Ptuj, Slovenia). You can may think that the path from Poetovio to Mursa is less complex than the path from Siscia to Mursa, but the former consists of 56 points, while the later consists of 37 (in two segments).</p>
<p><img src="../post-images/ov2_routeNormalization5.png" alt=""></p>
<p>In both cases, the points are spread unevenly across the polylines. When we distort the network with the center at Rome (with the same settings as with all the cartograms shown in this post) it seems like the path from Poetovio, rather than converging with the route from Siscia as it approaches Mursa (as we would expect) instead crosses and changes position relative to the center, implying that the road from Siscia to Mursa slows down and then speeds up as it approaches Mursa.</p>
<p><img src="../post-images/ov2_routeNormalization3.png" alt=""></p>
<p>This kind of behavior is also visible in the doglegs evident on the Danube to the right of Mursa. We can see these are artifacts of the polyline segmentation when we compare the distortion with the normalized routes:</p>
<p><img src="../post-images/ov2_routeNormalization4.png" alt=""></p>
<p>While the change is minor, and it was my intuition before effecting this normalization that it would be, in the aggregate this kind of error is visually jarring and interrupts an attempt to understand what is already a very abstract spatial representation. What intrigued me more than the technical details was that the first half of this code (the cartogram itself) needed to happen in the browser, since the transformation is dynamic and interactive and subject to the same variety of permutations available for calculating routes. But the second half (the line simplification) could have happened on the backend to produce a static data file. Instead, rather than being some kind of pre-processing technique, the negligible cost to recalculate the simplified routes affords the opportunity to provide level of detail controls that allow the reader to determine, say, the number of points per line if they want. More than that, I found it quicker to address this through dealing with the graphical structures rather than the geodata structures, which suprised me. While we live in an age of readily accessible and robust tools and libraries for geospatial manipulation, we also have simple and effective methods for manipulating graphical data. I'm sure much of my motivation for addressing this with D3 and SVG rather than <a href="http://postgis.net/">PostGIS</a> (or <a href="https://pypi.python.org/pypi/Shapely">Shapely</a>, for you Pythonistas out there) is because I use D3 a lot these days, but the capacity to do line simplification like this (or raster calculations with canvas or other traditional backend GIS) in the browser is revolutionary. What's more exciting than the growing capability to do this kind of thing in the browser is the necessity when delivering dynamic, interactive content like this.</p>
<p>* 3000 visits in the last week, which is small potatoes to a big Internet site, but rather remarkable for a scholarly site that hasn't added any new features for a couple years</p>

      </article>

      <!-- Tags --><!-- Author Box --><!-- Comments --></div>
  </div>
</div>


  </main>

  <script src="/assets/js/theme.js" "></script>

    <!-- Footer -->
    <footer class=" bg-white border-top p-3 text-muted small">
      <div class="container">
        <div class="row align-items-center justify-content-between">
          <div>
            <span class="navbar-brand mr-2 mb-0">
              <strong>Digital Humanities @ Stanford</strong>
            </span>
          </div>
          <div>
            <span>Copyright © 2022.</span>

            <a class="text-dark ml-1" href="https://github.com/dh-stanford/dh-stanford.github.io/" target="_blank">
              <i class="fab fa-github"></i>
              Site Source
            </a>
          </div>
        </div>
      </div>
    </footer>

  </body>

</html>
